# import hashlib
# import zlib
# import struct
# import itertools

# # Base byte values from the output
# base_byte_values = {
#     0: 0, 1: 24, 2: 108, 3: 121, 4: 31, 5: 15, 6: 24, 7: 97, 8: 40, 9: 25,
#     10: 10, 11: 24, 12: 94, 13: 86, 14: 73, 15: 49, 16: 116, 17: 82, 18: 16,
#     19: 53, 20: 35, 21: 115, 22: 25, 23: 11, 24: 35, 25: 116, 26: 32, 27: 61,
#     28: 28, 29: 67, 30: 120, 31: 64, 32: 52, 33: 75, 34: 112, 35: 80, 36: 68,
#     37: 17, 38: 35, 39: 19, 40: 96, 41: 6, 42: 8, 43: 27, 44: 63, 45: 97,
#     46: 56, 47: 15, 48: 89, 49: 32, 50: 100, 51: 10, 52: 92, 53: 25, 54: 33,
#     55: 26, 56: 85, 57: 12, 58: 97, 59: 6, 60: 54, 61: 125, 62: 69, 63: 40,
#     64: 48, 65: 99, 66: 31, 67: 28, 68: 82, 69: 60, 70: 7, 71: 24, 72: 15,
#     73: 28, 74: 105, 75: 116, 76: 68, 77: 38, 78: 28, 79: 66, 80: 18, 81: 1,
#     82: 90, 83: 21, 84: 19
# }

# # Convert uint32 values to byte representations
# uint32_values = {
#     3: 1818632293,
#     10: 2065722991,
#     17: 1735289202,
#     22: 1713643578,
#     28: 1378951712,
#     37: 860584289,
#     41: 1294233651,
#     46: 1916041068,
#     52: 1081685111,
#     59: 1865246066,
#     66: 539127151,
#     70: 1684959075,
#     80: 543564832
# }

# # Expected hash values
# expected_md5 = "b7dc94ca98aa58dabb5404541c812db2"
# expected_sha256_14_2 = "403d5f23d149670348b147a15eeb7010914701a7e99aad2e43f90cfa0325c76f"
# expected_crc32_8_2 = 0x61089c5c

# # Set up a function to generate the byte array with given values
# def generate_byte_array():
#     byte_array = bytearray(85)
#     for idx, val in base_byte_values.items():
#         byte_array[idx] = val
#     for idx, val in uint32_values.items():
#         byte_array[idx:idx+4] = struct.pack("<I", val)  # Little-endian format for uint32
#     return byte_array

# # Function to check if the current byte array matches all hash constraints
# def verify_hashes(byte_array):
#     md5_full = hashlib.md5(byte_array).hexdigest()
#     sha256_14_2 = hashlib.sha256(byte_array[14:16]).hexdigest()
#     crc32_8_2 = zlib.crc32(byte_array[8:10])
#     return (md5_full == expected_md5 and
#             sha256_14_2 == expected_sha256_14_2 and
#             crc32_8_2 == expected_crc32_8_2)

# # Embed the "@flare-on.com" flag ending
# def embed_flag_ending(byte_array):
#     flag_suffix = b'@flare-on.com'
#     suffix_length = len(flag_suffix)
#     byte_array[-suffix_length:] = flag_suffix
#     return byte_array

# # Attempt to brute-force by adjusting some byte positions
# def brute_force_for_hash():
#     mutable_positions = [14, 15, 25, 50]  # Positions to vary for hash matching
#     byte_array = generate_byte_array()
#     byte_array = embed_flag_ending(byte_array)  # Embed the flag ending

#     for values in itertools.product(range(256), repeat=len(mutable_positions)):
#         # Update byte array with the current brute-forced values
#         for pos, val in zip(mutable_positions, values):
#             byte_array[pos] = val

#         # Verbose output for current attempt
#         print(f"Testing values at positions {mutable_positions}: {values}")

#         # Check if this modified byte array meets all hash constraints
#         if verify_hashes(byte_array):
#             print("Match found with values:", values)
#             return byte_array

#     print("No solution found within the brute-force range.")
#     return None

# # Run the brute-force and generate the final file if successful
# result = brute_force_for_hash()
# if result:
#     with open("output_file_with_flag.bin", "wb") as f:
#         f.write(result)
#     print("File generated successfully with matching hash constraints and embedded flag ending!")
# else:
#     print("Failed to generate file with matching constraints.")

import struct

# Define known flag ending and target format positions
known_suffix = "@flare-on.com"

# Byte values generated by Z3
byte_values = {
    77: 32, 19: 41, 78: 76, 47: 90, 49: 60, 60: 25, 81: 14, 25: 29, 27: 61,
    71: 25, 82: 90, 8: 84, 69: 40, 5: 15, 14: 24, 80: 18, 83: 50, 1: 42,
    76: 36, 48: 89, 38: 51, 18: 15, 45: 97, 37: 29, 42: 17, 64: 40, 0: 51,
    17: 80, 34: 115, 39: 29, 12: 82, 15: 49, 43: 35, 57: 36, 79: 64, 67: 28,
    35: 80, 51: 106, 22: 25, 6: 16, 31: 16, 66: 31, 46: 56, 61: 125, 72: 15,
    44: 70, 10: 48, 59: 12, 20: 2, 23: 11, 52: 60, 41: 96, 56: 60, 13: 63,
    70: 7, 53: 25, 55: 16, 50: 64, 4: 125, 63: 32, 16: 116, 11: 24, 68: 34,
    9: 25, 73: 67, 3: 121, 32: 36, 33: 33, 24: 35, 62: 121, 29: 67, 30: 16,
    54: 102, 28: 28, 40: 27, 26: 32, 58: 97, 75: 116, 2: 108, 36: 68, 74: 105,
    65: 99, 84: 125
}

# uint32 values from Z3 output, in little-endian format
uint32_values = {
    3: 1818632293,
    10: 2065722991,
    17: 1735289202,
    22: 1713643578,
    28: 1378951712,
    37: 860584289,
    41: 1294233651,
    46: 1916041068,
    52: 1081685111,
    59: 1865246066,
    66: 539127151,
    70: 1684959075,
    80: 543564832
}

# Create the file content with a specified size
filesize = 85
file_content = bytearray([0] * filesize)

# Apply known `@flare-on.com` suffix in reverse order to align positions
suffix_offset = filesize - len(known_suffix)
for i, char in enumerate(known_suffix):
    file_content[suffix_offset + i] = ord(char)

# Apply Z3 byte values for the flag structure
for offset, value in byte_values.items():
    file_content[offset] = value

# Apply uint32 values by writing them as 4-byte sequences at the specified offsets
for offset, value in uint32_values.items():
    if offset + 4 <= filesize:
        file_content[offset:offset + 4] = struct.pack('<I', value)  # Little-endian

# Write to output file
with open("output.bin", "wb") as f:
    f.write(file_content)

# Print ASCII output to verify flag structure
ascii_output = ''.join(chr(b) if 32 <= b <= 126 else '.' for b in file_content)
print("ASCII output of file_content:", ascii_output)
print("File generated as output.bin.")






